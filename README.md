# e3extensions

TODO: project description

## Contents

* [Install](#install)
* [Usage](#usage)
* [TL;DR](#tldr)
* [Static vs Dynamic LibG](#static-vs-dynamic-libg)
* [Supported Operations](#supported-operations)
* [Cross Compiling](#cross-compiling)

## Install

In the e3extensions base directory:
````
make install
````

## Usage

### Coding

Follow the examples in the *test* directory.

### Preprocessing

If instead of hardcoding the arguments for the Cryptosystem and SecureInt objects, you decide to use the preprocessor capabilitities (as in *test/main/main.cpp*), you must to pass your code through the preprocessor.

In the *e3extensions* directory, do:

````
make preprocess CODE=test/main/main.cpp
````

### Compiling

The code generated by the preprocessor must be the one compiled.

From the *e3extensions* directory:
````
make compile CODE=test/main/main_T.cpp OUT=test/main/main.elf
````
If using dynamic libg:
````
make compile CODE=test/main/main_T.cpp OUT=test/main/main.elf LDFLAGS=-ldl
````
If using another compiler:
````
make compile CODE=test/main/main_T.cpp OUT=test/main/main.elf CC=or1k-elf-gcc CXX=or1k-elf-g++
````

### Running

In the *e3extensions* directory, do:
```
make run FILE=test/main/main.elf
```

## TL;DR

Let us create a program that performs a simple mathematical equation (1+15*10-7). First, create a directory in *test/*.
````
cd test/
mkdir simple
cd simple/
````
Create a C++ file (simple.cpp).
````
#include <iostream>
#include <fstream>
#include "../../src/e3extensions/secureint.h"

using namespace std;

string libgDir = "./libg.so";
string gFunctionName = "libg";

int main()
{
	cout << "Creating Cryptosystem\n";
	Cryptosystem cs(__PQ()()()()__, __BETA__, __2TOBETA__, __ENC0__, __ENC1__, libgDir, gFunctionName);
	cout << "Instantiating SecureInts\n";
	SecureInt a(__N(1)__,cs), b(__N(15)__,cs), c(__N(10)__,cs), d(__N(7)__,cs);
	cout << "Performing mathematical equation (it may take a while)\n";
	SecureInt r = a+b*c-d;
	cout << "Writing output file\n";
	ofstream out;
	out.open("output.txt", ofstream::out);
	out << r.str();
	out.close();

	return 0;
}

````
Then, from the e3extensions directory, let us use the makefile to preprocess the code:
````
make preprocess CODE=test/simple/simple.cpp
````
Now, compile the program:
````
make compile CODE=test/simple/simple_T.cpp OUT=test/simple/simple.elf LDFLAGS=-ldl
````
Run the application:
````
make run FILE=test/simple/simple.elf
````
It creates a file called output.txt with the encrypted result and shows the following messages during the run:
````
Creating Cryptosystem
Instantiating SecureInts
Performing mathematical equation (it may take a while)
Writing output file
````
If you check the output.txt, you will see an encrypted value. To see the unencrypted result, let us make another program (file: decrypt.cpp).
````
#include <fstream>
#include <iostream>
#include "../../src/preprocessor/sensitive_information.h"

#define FILENAME "CS.txt"

using namespace std;

Unumber p, q, k;

void loadCryptosystemParams();

int main()
{
	cout << "Loading Cryptosystem parameters\n";
	loadCryptosystemParams();
	cout << "Instantiating SensitiveInformation (to decrypt)\n";
	SensitiveInformation si(p,q,k);
	cout << "Reading encrypted value from output.txt\n";
	ifstream in;
	in.open("output.txt", ifstream::in);
	stringstream buffer;
	buffer << in.rdbuf();
	string strEncValue = buffer.str();
	in.close();
	Unumber encValue(strEncValue);
	cout << "Decrypting\n";
	Unumber R, result;
	result = si.decrypt(encValue, &R);
	cout << "Result: " << result.str() << " (encrypted value: " << encValue.str() << ")\n";

	return 0;
}

void loadCryptosystemParams()
{
	ifstream in;
	in.open(FILENAME, ifstream::in);
	stringstream buffer;
	buffer << in.rdbuf();
	string text = buffer.str();
	in.close();

	int semicolon[4];
	semicolon[0] = text.find(";") + 1;
	semicolon[1] = text.find(";", semicolon[0]) + 1;
	semicolon[2] = text.find(";", semicolon[1]) + 1;
	semicolon[3] = text.find(";", semicolon[2]) + 1;

	string strP = text.substr(semicolon[0], semicolon[1]-semicolon[0]-1);
	string strQ = text.substr(semicolon[1], semicolon[2]-semicolon[1]-1);
	string strK = text.substr(semicolon[2], semicolon[3]-semicolon[2]-1);

	p = Unumber(strP);
	q = Unumber(strQ);
	k = Unumber(strK);
}

````
Then compile it:
````
make compile CODE=test/simple/decrypt.cpp OUT=test/simple/decrypt.elf
````
Now, test it:
````
make run FILE=test/simple/decrypt.elf
````
You should get the following (the encrypted value may change):
````
Loading Cryptosystem parameters
Instantiating SensitiveInformation (to decrypt)
Reading encrypted value from output.txt
Decrypting
Result: 144 (encrypted value: 3268181710)
````
It shows 144 as the result, which is correct. Yahoo!

## Static vs Dynamic LibG

The Cryptosystem supports dynamic (shared object) or static (include) loading of LibG. The use of dynamic libG allows several G functions in the same code. But if the code is targeting baremetal or you are planning to use only one G function, the static libG may be more appropriate. The dynamic approach is the standard. To use the static, you must:
* *#define STATIC_LIBG* in the beggining of your code (see *test/main/main.cpp*)
* *#include "path/to/your/libg"* before including *secureint.h*
* name your G function in your libg file as *libg* (see *src/libg/libg.cpp*)

## Supported Operations

To help explaining the operators, SecureInt objects a and b containing encrypted values and k containing an unsigned integer are used.
Note: a ~ before a number means the encryption of that number and a _ before a variable means the decryption of that variable.

* == \[usage a==b\] returns ~1 if a is equal to b is true, and ~0 otherwise
* != \(usage a!=b\) returns ~1 if a is different from b is true, and ~0 otherwise
* + (unary, usage +a) returns a
* + (binary, a+b) returns an encrypted number that, if decrypted, is equivalent to the sum of _a and _b
* += (a+=b) same as above, but the returned value is automatically attributed to a
* - (unary, usage -a) returns the inverse of a, which, if decrypted, is equivalent to -(_a)
* - (binary, usage a-b) returns an encrypted number that, is decrypted, is equivalent to subtracting b from a
* -= (a-=b) same as above, but the returned value is automatically attributed to a
* \* (a*b) return an encrypted number that (if decrypted) is equivalent to the multiplication of _a and _b
* \*= (a\*=b) same as above, but the returned value is automatically attributed to a
* << (a<<k) returns an encrypted value that, if decrypted, is the same as shifting left _a k times
* <<= (a<<=k) same as above, but the returned value is automatically attributed to a
* >> (a>>k) returns an encrypted value that, if decrypted, is the same as shifting right _a k times
* >>= (a>>=k) same as above, but the returned value is automatically attributed to a


## Cross Compiling

To cross compile your code, use one of the following methods. Examples cross compiling to *openRISC 1000 baremetal* using code *test/main/main.cpp*.

#### Method 1

````
make compile-unumber CC=or1k-elf-gcc CXX=or1k-elf-g++
make preprocess CODE=test/main/main.cpp *# if code is already preprocessed, this comand is not necessary*
make compile CODE=test/main/main_T.cpp OUT=test/main/main.elf CC=or1k-elf-gcc CXX=or1k-elf-g++
````

#### Method 2

````
export C_COMPILER=or1k-elf-gcc
export CPP_COMPILER=or1k-elf-g++
make compile-unumber
make preprocess CODE=test/main/main.cpp *# if code is already preprocessed, this comand is not necessary*
make compile CODE=test/main/main_T.cpp OUT=test/main/main.elf
````

## MoMAlab

[Click here](http://sites.nyuad.nyu.edu/moma/) for more.
